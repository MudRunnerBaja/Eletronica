#include <Arduino.h>
#include <U8g2lib.h>
#include <SPI.h>
#include <Wire.h>
#include <SoftwareSerial.h>

unsigned int t0, tf; // Timers
char tvel[10]; // String responsável por mostrar o valor da velocidade
char trpm[10]; // String responsável por mostrar o valor do RPM
int vel = 00, rpm = 0000; // Valores arbitrários de teste
float rpmmax = 4500, wprpm, w;
bool CVT = true, reserva = false, gps_conn = false, sd_rw = false, conn = false, intialized = false;
bool I2C = false;
unsigned long ti2c;
short comb = 0;
byte receivedData[5]; // Buffer de dados recebidos. Tamanho máximo de 32 bytes.

// Funções de inicialização do objeto u8g2 do display. Quando usando HW_SPI, apenas o SS precisa ser passado.

static unsigned char mud_xbm[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 
  0x64, 0xD6, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0xFF, 0xFF, 0x22, 0xD5, 0xFB, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0xFE, 0x7F, 
  0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 
  0x00, 0x00, 0xFE, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFE, 0x1F, 0x00, 0x00, 0x00, 0x00, 
  0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xFF, 0x07, 
  0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 
  0x16, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x80, 0x7F, 0x00, 0x5C, 0x01, 0x00, 0x00, 
  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x3F, 0x00, 
  0xFC, 0xFF, 0xFF, 0x01, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x1F, 0x80, 0x1F, 0x00, 0xFC, 0xFF, 0xFF, 0x0F, 0x00, 0xFE, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xC0, 0x0F, 0x00, 0xFE, 0xF7, 0xFF, 0x1F, 
  0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xC0, 0x07, 0x00, 
  0xFF, 0x81, 0xFF, 0x1F, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x07, 0xE0, 0x03, 0x00, 0x7F, 0x00, 0xFF, 0x1F, 0x00, 0xFE, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xE0, 0x01, 0x00, 0x3F, 0x00, 0xFF, 0x1F, 
  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xF0, 0x00, 0x80, 
  0x1F, 0x00, 0xFF, 0x1F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x03, 0x70, 0x00, 0x80, 0x0F, 0x00, 0xFF, 0x0F, 0x80, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x18, 0x10, 0xC0, 0x07, 0x00, 0xFF, 0x07, 
  0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x18, 0x18, 0xC0, 
  0x01, 0x80, 0xFF, 0x01, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x01, 0x0C, 0x0C, 0xE0, 0x00, 0x80, 0x7F, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x06, 0x60, 0x00, 0xC0, 0x0F, 0x00, 
  0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x07, 0x30, 
  0x00, 0xC0, 0x02, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 
  0x00, 0x80, 0x03, 0x10, 0x08, 0x60, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xC0, 0x03, 0x00, 0x0C, 0x60, 0x00, 0xFC, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xE0, 0x03, 0x00, 
  0x06, 0xF0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 
  0x00, 0xF0, 0x01, 0x00, 0x03, 0xF0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xF8, 0x00, 0x80, 0x03, 0xF8, 0x01, 0xF8, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0xFC, 0x00, 0xC0, 
  0x03, 0xF8, 0x01, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 
  0x00, 0x7E, 0x00, 0xF0, 0x01, 0xFC, 0x03, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x7F, 0x00, 0xF8, 0x00, 0xFC, 0x03, 0xF0, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x80, 0x7F, 0x00, 0xFC, 
  0x00, 0xFE, 0x03, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 
  0xC0, 0x3F, 0x00, 0xFE, 0x00, 0xFE, 0x07, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0x07, 0xE0, 0x3F, 0x00, 0x7F, 0x00, 0x20, 0x04, 0xC0, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xF0, 0x3F, 0x80, 0x7F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2B, 
  0xFC, 0x7F, 0xC0, 0x7F, 0x00, 0x00, 0x10, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xFF, 0x01, 0x00, 0x1C, 0x00, 
  0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFB, 0xFF, 0x86, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
   };

void WaitSerial(bool wait);

// I2C
int sdaPin = 20, sclPin = 21;

// LCD
int SCKPIN = 10, CSPIN = 13;
int TXPIN = 11; // MOSI
int RXPIN = 12; // MISO
U8G2_ST7920_128X64_F_SW_SPI u8g2(U8G2_R2, SCKPIN, TXPIN, CSPIN);
//U8G2_ST7920_128X64_1_HW_SPI u8g2(U8G2_R2, 10);
//U8G2_ST7920_128X64_1_2ND_HW_SPI u8g2(U8G2_R0, 17);



// Setup dos leds do display
int ledVerde = 2, ledAmarelo = 1, ledVermelho = 0, ledCVT = 18;

enum nivel {
    VAZIO,
    MEDIO,
    CHEIO
};

void receiveEvent(int bytesReceived);

void setup(void) 
{ 
  pinMode(ledVermelho,OUTPUT);
  pinMode(ledAmarelo,OUTPUT);
  pinMode(ledVerde,OUTPUT);

  
  

  WaitSerial(false);
  t0 = tf = millis();
  Wire.setSDA(sdaPin);
  Wire.setSCL(sclPin);
  
  /*
  SPI1.setRX(RXPIN);
  SPI1.setTX(TXPIN);
  SPI1.setSCK(SCKPIN);
  SPI1.setCS(CSPIN);
  SPI1.begin(true);
  */
  
  Serial.begin(9600);
  u8g2.begin();
  
  Wire.begin(9);
  Wire.onReceive(receiveEvent); // Evento -> chama a função receiveEvent quando recebe uma transmissão pelo i2c
  
  // Converte os valores de int para char e insere os chars nas strings declaradas no início.
  itoa(vel/10, &tvel[0], 10);
  itoa(vel%10, &tvel[1], 10);
  itoa(rpm/1000, &trpm[0], 10);
  itoa((rpm/100)%10, &trpm[1], 10);
  itoa((rpm%100)/10, &trpm[2], 10);
  itoa(rpm%10, &trpm[3], 10);

  wprpm = 128/rpmmax;
  loadScreen();

  for (size_t i = 0; i < 255; i++)
  {
    analogWrite(ledVermelho, i);
    delay(5);
  }
  for (size_t i = 0; i < 255; i++)
  {
    analogWrite(ledAmarelo , i);
    delay(5);
  }
  for (size_t i = 0; i < 255; i++)
  {
    analogWrite(ledVerde , i);
    delay(5);
  }
  
  delay(100);
  
  Serial.println("Funcionando aqui");
  loadScreen();
  
  for (size_t i = 255; i > 0; i--)
  {
    analogWrite(ledVerde, i);
    delay(3);
  }
  for (size_t i = 255; i > 0; i--)
  {
    analogWrite(ledAmarelo , i);
    delay(3);
  }
  for (size_t i = 255; i > 0; i--)
  {
    analogWrite(ledVermelho , i);
    delay(3);
  }
}


void UpdateDisplay() {
  u8g2.firstPage();
  do {
    bool warning = false;

    //######### CONTEUDOS DO DISPLAY #########
    u8g2.setDrawColor(1);
    //######### RPM #########
    u8g2.setFont(u8g2_font_timB24_tf);
    u8g2.drawButtonUTF8(2, 35 , U8G2_BTN_INV, 128, 2, 0, trpm);

    //######### BARRA ATIVA RPM #########
    u8g2.drawFrame(0,0,128,12);
    w = rpm * wprpm;
    u8g2.drawBox(0,0,w,12);

    //######### VELOCIDADE #########
    u8g2.setFont(u8g2_font_lubB18_te);
    u8g2.drawButtonUTF8(2, 60 , U8G2_BTN_INV|U8G2_BTN_BW2, 32, 0, 0, tvel);

    //JUNÇÃO DA CAIXA DE VELOCIDADE COM A CAIXA DE RPM
    u8g2.drawTriangle(36,66, 36,40, 61,40);

    //######### NIVEL DE COMBUSTIVEL BAIXO #########
    if (reserva){
      u8g2.setFont(u8g2_font_t0_11b_te);
      u8g2.drawButtonUTF8(98, 62, U8G2_BTN_INV|U8G2_BTN_BW1, 0, 0, 0, "!FUEL");
    }

    //######### TEMPERATURA CVT ALTA #########
   if (CVT){
      u8g2.setFont(u8g2_font_t0_11b_te);
      u8g2.drawButtonUTF8(98, 50, U8G2_BTN_INV|U8G2_BTN_BW1, 0, 0, 0, "!TCVT");
      warning = true;
    }


    //######### CONECTADO AO MASTER #########
    if(I2C){
      u8g2.setDrawColor(0);
      u8g2.setFont(u8g2_font_siji_t_6x10);
      u8g2.drawGlyph(77, 20, 0xe20e);
    }else{
      u8g2.setDrawColor(0);
      u8g2.setFont(u8g2_font_siji_t_6x10);
      u8g2.drawGlyph(77, 19, 0xe20f);

      u8g2.setFont(u8g2_font_t0_11b_te);
      u8g2.setDrawColor(1);
      u8g2.drawButtonUTF8(70, 50, U8G2_BTN_INV|U8G2_BTN_BW1, 0, 0, 0, "!I2C");
    }

    //######### GRAVAÇÃO CARTÃO SD #########
    if(sd_rw){
      u8g2.setDrawColor(0);
      u8g2.setFont(u8g2_font_siji_t_6x10);
      u8g2.drawGlyph(77, 30, 0xe1e1);
    }else{
      u8g2.setDrawColor(0);
      u8g2.setFont(u8g2_font_siji_t_6x10);
      u8g2.drawGlyph(77, 32, 0xe0ae);

      u8g2.setDrawColor(1);
      u8g2.setFont(u8g2_font_t0_11b_te);
      u8g2.drawButtonUTF8(48, 62, U8G2_BTN_INV|U8G2_BTN_BW1, 0, 0, 0, "!SD");
      warning = true;
    }
    
    //######### SINAL DE GPS #########
    if (gps_conn){
      u8g2.setDrawColor(0);
      u8g2.setFont(u8g2_font_siji_t_6x10);
      u8g2.drawGlyph(77, 40, 0xe1ba);
    }else{
      u8g2.setDrawColor(0);
      u8g2.setFont(u8g2_font_siji_t_6x10);
      u8g2.drawGlyph(77, 40, 0xe217);

      u8g2.setDrawColor(1);
      u8g2.setFont(u8g2_font_t0_11b_te);
      u8g2.drawButtonUTF8(70, 62, U8G2_BTN_INV|U8G2_BTN_BW1, 0, 0, 0, "!GPS");
      warning = true;
    }

    

    //######### INDICADOR DE ATENÇÃO #########
    if (warning){
      u8g2.setDrawColor(0);
      u8g2.setFont(u8g2_font_streamline_interface_essential_circle_triangle_t);
      u8g2.drawGlyph(100,36, 0x34);
    }

  } while (u8g2.nextPage());
  setarCombustivel(comb);
  if (CVT) digitalWrite(ledCVT, HIGH);
  else digitalWrite(ledCVT, LOW);
  
}

void receiveEvent(int bytesReceived) {  // É requisito que essas funções de evento tenham um parâmetro int.
  int b = 0; // Contador de bytes recebidos. Útil pra testar ou limitar a transmissão.
  while(Wire.available()) {
    receivedData[b] = Wire.read();
    Serial.print("byte ");Serial.print(b + " ");Serial.println(receivedData[b]);
    b++;
  }
   // Como recebemos em bytes e int são data types de 2 bytes, precisamos transformar o byte mais alto em int e movê-lo para a esquerda. Um byte são 8 bits.
   // Depois, recebemos o byte mais baixo.
  vel = (int)receivedData[0] << 8 | (int)receivedData[1]; // Transforma byte receivedData[0] em int e o move 8 bits para a esquerda, e depois transforma e recebe o byte receivedData[1].
  rpm = (int)receivedData[2] << 8 | (int)receivedData[3];
  CVT = receivedData[4] & 0x04;
  comb = receivedData[4] & 0x03;
  gps_conn = (receivedData[4] & 0x08);
  sd_rw = (receivedData[4] >> 4);
  I2C = true;
  ti2c = millis();

  // Converte os valores de int para char e insere os chars nas strings declaradas no início.
  itoa(vel/10, &tvel[0], 10);
  itoa(vel%10, &tvel[1], 10);
  itoa(rpm/1000, &trpm[0], 10);
  itoa((rpm/100)%10, &trpm[1], 10);
  itoa((rpm%100)/10, &trpm[2], 10);
  itoa(rpm%10, &trpm[3], 10);

  Serial.print("Recebido. Vel: ");Serial.println(tvel);
  Serial.print("Recebido. RPM: ");Serial.println(trpm);

}

void setarCombustivel(int nivel)
{
    if (nivel == CHEIO)
    {
        analogWrite(ledVerde, 255);
        analogWrite(ledAmarelo, 0);
        analogWrite(ledVermelho, 0);
        reserva = false;

    }
    else if (nivel == MEDIO)
    {
        analogWrite(ledVerde, 0);
        analogWrite(ledAmarelo, 255);
        analogWrite(ledVermelho, 0);
        reserva = false;
    }
    else // VAZIO
    {
        analogWrite(ledVerde, 0);
        analogWrite(ledAmarelo, 0);
        analogWrite(ledVermelho, 255);
        reserva = true;
    }
}

void loop(void) {
    int test = millis();

    if((millis() - ti2c) >  1000){
      I2C = false;
    }

    UpdateDisplay();
    int timetest = millis() - test;
    
    //Serial.print("\nTempo Trocando:");Serial.println(timetest);
    //Serial.print("vel:");Serial.println(vel);
}

void WaitSerial(bool wait)
{
  if (wait)
  {
    while (!Serial) {
      yield();
    }
    delay(100);

    Serial.println(F("Type any character to start"));
    while (!Serial.available()) {
      yield();
    }
  }
  return;
}

void loadScreen(){
  u8g2.firstPage();
  do {
  u8g2.setDrawColor(0);
  u8g2.drawXBM( 0, 0, 128, 64, mud_xbm);
  if (intialized){
    u8g2.setDrawColor(1);
    u8g2.setFont(u8g2_font_t0_13_te);
    u8g2.drawButtonUTF8(16, 62, U8G2_BTN_INV|U8G2_BTN_BW1, 0, 0, 0, "Inicializado!");
    u8g2.setFont(u8g2_font_5x8_tf);
    u8g2.drawButtonUTF8(2, 7, U8G2_BTN_INV|U8G2_BTN_BW1, 0, 0, 0, "Eletronica MudRunner 2023");
  } else {
    u8g2.setDrawColor(1);
    u8g2.setFont(u8g2_font_t0_13_te);
    u8g2.drawButtonUTF8(16, 62, U8G2_BTN_INV|U8G2_BTN_BW1, 0, 0, 0, "Inicializando...");
    u8g2.setFont(u8g2_font_5x8_tf);
    u8g2.drawButtonUTF8(2, 7, U8G2_BTN_INV|U8G2_BTN_BW1, 0, 0, 0, "Eletronica MudRunner 2023");
  }
  
  } while (u8g2.nextPage());
  intialized = true;
}
